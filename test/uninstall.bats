#!/usr/bin/env bats
# Unit tests for uninstall.sh

load 'test_helper'

setup() {
    setup_test_environment

    # Source uninstall.sh functions
    local uninstall_script="$BATS_TEST_DIRNAME/../uninstall.sh"
    eval "$(sed 's/^main "\$@"$/# main disabled for testing/' "$uninstall_script")"
}

teardown() {
    teardown_test_environment
}

# =============================================================================
# detect_waveterm_config() tests (also in uninstall.sh)
# =============================================================================

@test "uninstall: detect_waveterm_config finds config path" {
    mkdir -p "$TEST_HOME/.config/waveterm"

    run detect_waveterm_config

    [ "$status" -eq 0 ]
    [ "$output" = "$TEST_HOME/.config/waveterm" ]
}

# =============================================================================
# load_config() tests
# =============================================================================

@test "uninstall: load_config uses defaults" {
    rm -f "$TEST_CONFIG_FILE"
    unset WAVE_NOTES_DIR
    unset WAVE_BIN_DIR

    load_config

    [ "$NOTES_DIR" = "$TEST_HOME/Documents/WaveNotes" ]
    [ "$BIN_DIR" = "$TEST_HOME/bin" ]
}

@test "uninstall: load_config reads config file" {
    cat > "$TEST_CONFIG_FILE" << EOF
NOTES_DIR="$TEST_HOME/CustomNotes"
BIN_DIR="$TEST_HOME/CustomBin"
EOF
    unset WAVE_NOTES_DIR
    unset WAVE_BIN_DIR

    load_config

    [ "$NOTES_DIR" = "$TEST_HOME/CustomNotes" ]
    [ "$BIN_DIR" = "$TEST_HOME/CustomBin" ]
}

@test "uninstall: load_config respects environment variables" {
    export WAVE_NOTES_DIR="$TEST_HOME/EnvNotes"
    export WAVE_BIN_DIR="$TEST_HOME/EnvBin"

    load_config

    [ "$NOTES_DIR" = "$TEST_HOME/EnvNotes" ]
    [ "$BIN_DIR" = "$TEST_HOME/EnvBin" ]
}

# =============================================================================
# remove_widgets() tests
# =============================================================================

@test "remove_widgets: removes notes widgets from widgets.json" {
    WAVETERM_CONFIG="$TEST_WAVETERM_CONFIG"
    cat > "$WAVETERM_CONFIG/widgets.json" << 'EOF'
{
  "existing:widget": { "display:order": 1 },
  "custom:notes-new": { "display:order": 2 },
  "custom:notes-list": { "display:order": 3 },
  "another:widget": { "display:order": 4 }
}
EOF

    remove_widgets

    assert_json_has_key "$WAVETERM_CONFIG/widgets.json" "existing:widget"
    assert_json_has_key "$WAVETERM_CONFIG/widgets.json" "another:widget"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-new"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-list"
}

@test "remove_widgets: preserves other widgets" {
    WAVETERM_CONFIG="$TEST_WAVETERM_CONFIG"
    cat > "$WAVETERM_CONFIG/widgets.json" << 'EOF'
{
  "defwidget@terminal": { "display:order": 1 },
  "custom:notes-new": { "display:order": 2 },
  "custom:other": { "display:order": 3 }
}
EOF

    remove_widgets

    assert_json_has_key "$WAVETERM_CONFIG/widgets.json" "defwidget@terminal"
    assert_json_has_key "$WAVETERM_CONFIG/widgets.json" "custom:other"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-new"
}

@test "remove_widgets: handles missing widgets.json gracefully" {
    WAVETERM_CONFIG="$TEST_WAVETERM_CONFIG"
    rm -f "$WAVETERM_CONFIG/widgets.json"

    run remove_widgets

    [ "$status" -eq 0 ]
    [[ "$output" == *"No widgets.json found"* ]]
}

@test "remove_widgets: handles empty widgets.json" {
    WAVETERM_CONFIG="$TEST_WAVETERM_CONFIG"
    echo '{}' > "$WAVETERM_CONFIG/widgets.json"

    run remove_widgets

    [ "$status" -eq 0 ]
    [ -f "$WAVETERM_CONFIG/widgets.json" ]
}

@test "remove_widgets: removes all notes- prefixed widgets" {
    WAVETERM_CONFIG="$TEST_WAVETERM_CONFIG"
    cat > "$WAVETERM_CONFIG/widgets.json" << 'EOF'
{
  "custom:notes-new": { "display:order": 1 },
  "custom:notes-list": { "display:order": 2 },
  "custom:notes-browser": { "display:order": 3 },
  "custom:notes-recent": { "display:order": 4 },
  "custom:other": { "display:order": 5 }
}
EOF

    remove_widgets

    assert_json_has_key "$WAVETERM_CONFIG/widgets.json" "custom:other"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-new"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-list"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-browser"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-recent"
}

# =============================================================================
# remove_script() tests
# =============================================================================

@test "remove_script: removes script with correct header" {
    BIN_DIR="$TEST_HOME/bin"
    mkdir -p "$BIN_DIR"
    cat > "$BIN_DIR/wave-scratch.sh" << 'EOF'
#!/bin/bash
# Generated by wave-notes-setup v1.0.0
echo "test"
EOF

    remove_script

    [ ! -f "$BIN_DIR/wave-scratch.sh" ]
}

@test "remove_script: skips script without correct header" {
    BIN_DIR="$TEST_HOME/bin"
    mkdir -p "$BIN_DIR"
    cat > "$BIN_DIR/wave-scratch.sh" << 'EOF'
#!/bin/bash
# Custom script by user
echo "test"
EOF

    run remove_script

    [ "$status" -eq 0 ]
    [ -f "$BIN_DIR/wave-scratch.sh" ]
    [[ "$output" == *"Skipping"* ]] || [[ "$output" == *"modified"* ]]
}

@test "remove_script: handles missing script gracefully" {
    BIN_DIR="$TEST_HOME/bin"
    mkdir -p "$BIN_DIR"
    rm -f "$BIN_DIR/wave-scratch.sh"

    run remove_script

    [ "$status" -eq 0 ]
    [[ "$output" == *"No wave-scratch.sh found"* ]]
}

# =============================================================================
# Integration tests
# =============================================================================

@test "integration: uninstall after install leaves no notes widgets" {
    # First, simulate an install
    NOTES_DIR="$TEST_HOME/TestNotes"
    BIN_DIR="$TEST_HOME/TestBin"
    WAVETERM_CONFIG="$TEST_WAVETERM_CONFIG"

    mkdir -p "$NOTES_DIR" "$BIN_DIR"

    # Create widgets.json with notes widgets
    cat > "$WAVETERM_CONFIG/widgets.json" << EOF
{
  "existing:widget": { "display:order": 1 },
  "custom:notes-new": { "display:order": 2, "label": "note" },
  "custom:notes-list": { "display:order": 3, "label": "All Notes" }
}
EOF

    # Create script
    cat > "$BIN_DIR/wave-scratch.sh" << 'EOF'
#!/bin/bash
# Generated by wave-notes-setup v1.0.0
echo "test"
EOF

    # Run uninstall functions
    remove_widgets
    remove_script

    # Verify
    assert_json_has_key "$WAVETERM_CONFIG/widgets.json" "existing:widget"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-new"
    assert_json_not_has_key "$WAVETERM_CONFIG/widgets.json" "custom:notes-list"
    [ ! -f "$BIN_DIR/wave-scratch.sh" ]
}

@test "integration: uninstall preserves user data by default" {
    NOTES_DIR="$TEST_HOME/TestNotes"
    BIN_DIR="$TEST_HOME/TestBin"
    WAVETERM_CONFIG="$TEST_WAVETERM_CONFIG"

    mkdir -p "$NOTES_DIR"
    echo "My important note" > "$NOTES_DIR/note.md"

    # Note: prompt_notes_deletion is interactive, we just verify directory exists
    # The actual deletion would require user input

    [ -d "$NOTES_DIR" ]
    [ -f "$NOTES_DIR/note.md" ]
}

# =============================================================================
# Security tests
# =============================================================================

@test "security: uninstall validate_safe_path rejects paths outside HOME" {
    run validate_safe_path "/etc/evil" "TEST_PATH"
    [ "$status" -ne 0 ]

    run validate_safe_path "/tmp/notes" "TEST_PATH"
    [ "$status" -ne 0 ]
}

@test "security: uninstall validate_safe_path rejects path traversal sequences" {
    run validate_safe_path "$TEST_HOME/../../../etc/passwd" "TEST_PATH"
    [ "$status" -ne 0 ]
    [[ "$output" == *"cannot contain '..'"* ]]

    run validate_safe_path "$TEST_HOME/notes/../../../etc" "TEST_PATH"
    [ "$status" -ne 0 ]
    [[ "$output" == *"cannot contain '..'"* ]]
}

@test "security: uninstall validate_safe_path rejects shell metacharacters" {
    # Test command injection attempt with semicolon
    run validate_safe_path "$TEST_HOME/notes;echo injected" "TEST_PATH"
    [ "$status" -ne 0 ]
    [[ "$output" == *"invalid characters"* ]]

    # Test with quotes
    run validate_safe_path "$TEST_HOME/notes\"rm" "TEST_PATH"
    [ "$status" -ne 0 ]

    # Test with dollar sign
    run validate_safe_path "$TEST_HOME/notes\$PATH" "TEST_PATH"
    [ "$status" -ne 0 ]
}

@test "security: uninstall validate_safe_path rejects protected directories" {
    mkdir -p "$TEST_HOME/Desktop"
    mkdir -p "$TEST_HOME/Documents"
    mkdir -p "$TEST_HOME/Downloads"
    mkdir -p "$TEST_HOME/Library"

    run validate_safe_path "$TEST_HOME" "TEST_PATH"
    [ "$status" -ne 0 ]

    run validate_safe_path "$TEST_HOME/Desktop" "TEST_PATH"
    [ "$status" -ne 0 ]

    run validate_safe_path "$TEST_HOME/Documents" "TEST_PATH"
    [ "$status" -ne 0 ]

    run validate_safe_path "$TEST_HOME/Downloads" "TEST_PATH"
    [ "$status" -ne 0 ]

    run validate_safe_path "$TEST_HOME/Library" "TEST_PATH"
    [ "$status" -ne 0 ]
}

@test "security: uninstall validate_safe_path rejects Library subdirectories" {
    # Library subdirectories should also be protected
    run validate_safe_path "$TEST_HOME/Library/Application Support" "TEST_PATH"
    [ "$status" -ne 0 ]
    [[ "$output" == *"cannot be in Library"* ]]

    run validate_safe_path "$TEST_HOME/Library/Preferences" "TEST_PATH"
    [ "$status" -ne 0 ]
}

@test "security: uninstall validate_safe_path accepts valid paths under HOME" {
    mkdir -p "$TEST_HOME/Documents/WaveNotes"
    mkdir -p "$TEST_HOME/MyNotes"

    run validate_safe_path "$TEST_HOME/Documents/WaveNotes" "TEST_PATH"
    [ "$status" -eq 0 ]

    run validate_safe_path "$TEST_HOME/MyNotes" "TEST_PATH"
    [ "$status" -eq 0 ]
}

@test "security: uninstall validate_safe_path accepts paths with missing parents" {
    run validate_safe_path "$TEST_HOME/NewDir/WaveNotes" "TEST_PATH"
    [ "$status" -eq 0 ]
}

@test "security: uninstall check_not_symlink detects symlinks" {
    local target="$TEST_HOME/real_file"
    local link="$TEST_HOME/symlink"

    echo "content" > "$target"
    ln -s "$target" "$link"

    run check_not_symlink "$link"
    [ "$status" -ne 0 ]

    run check_not_symlink "$target"
    [ "$status" -eq 0 ]
}

@test "security: safe_rmdir rejects protected directories including Downloads" {
    mkdir -p "$TEST_HOME/Desktop"
    mkdir -p "$TEST_HOME/Documents"
    mkdir -p "$TEST_HOME/Downloads"

    run safe_rmdir "$TEST_HOME/Desktop"
    [ "$status" -ne 0 ]

    run safe_rmdir "$TEST_HOME/Documents"
    [ "$status" -ne 0 ]

    run safe_rmdir "$TEST_HOME/Downloads"
    [ "$status" -ne 0 ]

    # Verify directories still exist
    [ -d "$TEST_HOME/Desktop" ]
    [ -d "$TEST_HOME/Documents" ]
    [ -d "$TEST_HOME/Downloads" ]
}
